<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【UE4】使用RenderDoc来调试渲染]]></title>
      <url>/ue4-using-renderdoc-to-debug-graphics/</url>
      <content type="html"><![CDATA[<p>RenderDoc（<a href="https://renderdoc.org/" target="_blank" rel="external">Official Site</a>，<a href="https://github.com/baldurk/renderdoc" target="_blank" rel="external">Github</a>）是一个图形渲染调试器，目前支持Window7-10和Linux上Vulkan、D3D11、D3D12和OpenGL的调试。通过使用RenderDoc，可以很方便的对我们的游戏渲染流程进行调试和分析。<br><a id="more"></a></p>
<h2 id="安装并启动RenderDoc"><a href="#安装并启动RenderDoc" class="headerlink" title="安装并启动RenderDoc"></a>安装并启动RenderDoc</h2><p>按照如下步骤操作：</p>
<ol>
<li>前往<a href="https://renderdoc.org/builds" target="_blank" rel="external">官方下载地址</a>，下载并安装。</li>
<li>打开UE4编辑器，Edit-&gt;Plugins-&gt;Rendering-&gt;RenderDoc Plugin，勾选Enabled启用。</li>
<li>重启编辑器，即可在Viewport右上角看到如下图的新按钮。<img src="/images/ue4-using-renderdoc-to-debug-graphics_img/viewport-icon.png" alt="ViewportIcon"></li>
<li>点击该按钮即可打开RenderDoc并自动捕获下一帧。</li>
<li>双击即可打开并查看捕获到的渲染帧信息。</li>
<li>点击Trigger即可捕获新的渲染帧。</li>
</ol>
<h2 id="开启UE4的Shader调试"><a href="#开启UE4的Shader调试" class="headerlink" title="开启UE4的Shader调试"></a>开启UE4的Shader调试</h2><p>在使用RenderDoc的时候查看Shader会看到汇编代码片段，想看到源代码需要进行如下操作：</p>
<ol>
<li>找到并打开<code>Engine\Config\ConsoleVariables.ini</code>。</li>
<li><p>取消注释如下两行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r.Shaders.Optimize=0</div><div class="line">r.Shaders.KeepDebugInfo=1</div></pre></td></tr></table></figure>
</li>
<li><p>重启引擎。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> ue4 </category>
            
            <category> debug </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> renderdoc </tag>
            
            <tag> debug </tag>
            
            <tag> graphics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【UE4】避免因为某些ini配置变动而重新Cook资源]]></title>
      <url>/ue4-avoid-recook-when-ini-changes/</url>
      <content type="html"><![CDATA[<p>最近经常打包，发现每次打包资源都全部重新Cook了，这对工作效率影响很大，原因包括我们在打包流程中自动修改了ini文件来配置版本号等。不经过配置的引擎会在ini进行变动的时候清理掉原有Cook过的内容。因此需要通过一系列配置，以保证每次Cook的内容是增量的，来加快工作进度。</p>
<a id="more"></a>
<p>首先要使增量Cook生效，必须在构建命令中加入<code>-iterate</code>，否则在每次Cook前会将Cook产物文件夹整个删除。<br>然后需要在<code>DefaultEditor.ini</code>文件中加入类似如下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">[CookSettings]</span></div><div class="line">+ConfigSettingBlacklist=*.Engine:/Script/IOSRuntimeSettings.IOSRuntimeSettings:VersionInfo</div><div class="line">+ConfigSettingBlacklist=*.Engine:/Script/AndroidRuntimeSettings.AndroidRuntimeSettings:VersionDisplayName</div><div class="line">+ConfigSettingBlacklist=*.Engine:/Script/AndroidRuntimeSettings.AndroidRuntimeSettings:StoreVersion</div></pre></td></tr></table></figure>
<p>实际上是通过配置增加<code>ConfigSettingBlacklist</code>中的内容项来时引擎在Cook的时候忽略相关的配置字段。其格式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ConfigSettingBlacklist=BuildMachinePlatform.ConfigFile:SectionName:ValueName</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<table>
<thead>
<tr>
<th>占位名</th>
<th>C++中的涵义</th>
<th>ini中的涵义</th>
<th>参考取值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BuildMachinePlatform</code></td>
<td>N/A</td>
<td>构建机器的平台</td>
<td>取值可以为<code>Windows/Mac/Linux</code>等,支持Wildcard(<code>*</code>)。</td>
</tr>
<tr>
<td><code>ConfigFile</code></td>
<td>C++类中<code>UCLASS(config=Engine)</code>配置的内容</td>
<td><code>ini</code>文件名的后半段，即<code>Base、Default</code>等字样后面的部分</td>
<td><code>Engine/Game/Editor</code>等</td>
</tr>
<tr>
<td><code>SectionName</code></td>
<td>C++类所属的路径名(<code>Path/Of/Package.ClassPath</code>)</td>
<td>每个配置文件中方括号内的内容</td>
<td>略</td>
</tr>
<tr>
<td><code>ValueName</code></td>
<td>C++类中的变量名</td>
<td>配置文件中具体的配置里行首的名称</td>
<td>略，支持Wildcard(<code>*</code>)</td>
</tr>
</tbody>
</table>
<p>配置成功后，将会在下下次打包时生效。</p>
]]></content>
      
        <categories>
            
            <category> ue4 </category>
            
            <category> cook </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cook </tag>
            
            <tag> ini </tag>
            
            <tag> config </tag>
            
            <tag> long time </tag>
            
            <tag> ue4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文章目录]]></title>
      <url>/index/</url>
      <content type="html"><![CDATA[<p>制作一个游戏需要各种技术，本文按照工作流程分别总结了各种技术及经验，并归类形成目录。主要使用的工具是Blender（模型、动画）、Substance Painter（贴图）、Unreal Engine 4（游戏引擎）。<br><a id="more"></a></p>
<h2 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><ol>
<li>基础建模</li>
<li>雕刻精细模型</li>
<li>重拓扑</li>
<li>模型减面</li>
</ol>
<h4 id="拆分UV"><a href="#拆分UV" class="headerlink" title="拆分UV"></a>拆分UV</h4><h4 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h4><ol>
<li>顶点颜色</li>
<li>PBR</li>
<li>法线贴图</li>
</ol>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h4 id="骨骼"><a href="#骨骼" class="headerlink" title="骨骼"></a>骨骼</h4><h4 id="蒙皮"><a href="#蒙皮" class="headerlink" title="蒙皮"></a>蒙皮</h4><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><h4 id="变形动画"><a href="#变形动画" class="headerlink" title="变形动画"></a>变形动画</h4><h2 id="技术美术"><a href="#技术美术" class="headerlink" title="技术美术"></a>技术美术</h2><h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><h3 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h3><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="Cook"><a href="#Cook" class="headerlink" title="Cook"></a>Cook</h3><p><a href="/ue4-avoid-recook-when-ini-changes">【UE4】避免因为某些ini配置变动而重新Cook资源</a></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><a href="/ue4-using-renderdoc-to-debug-graphics">【Ue4】使用RenderDoc来调试渲染</a></p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><a href="/ue4-dynamic-load-blueprint-class-from-path">【UE4】根据路径动态加载蓝图类的正确方式</a></p>
]]></content>
      
        <categories>
            
            <category> summary </category>
            
        </categories>
        
        
        <tags>
            
            <tag> index </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS转移记录]]></title>
      <url>/vps-transfer-logs/</url>
      <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><a href="https://www.linode.com/?r=2af2507483b1f6a2ac10fc9f757e43ac1d520477" target="_blank" rel="external">Linode</a>有5美元的机器了，内存也比Vultlr大一些，于是决定切换到<a href="https://www.linode.com/?r=2af2507483b1f6a2ac10fc9f757e43ac1d520477" target="_blank" rel="external">Linode</a><del>东京2机房</del>，记录一下全部流程，以供日后参考。<br><a id="more"></a></p>
<h2 id="更新：因为一些原因，再次切换"><a href="#更新：因为一些原因，再次切换" class="headerlink" title="更新：因为一些原因，再次切换"></a>更新：因为一些原因，再次切换</h2><p>使用了整快硬盘切换，下次无需再部署环境了。</p>
<ol>
<li>两台机器同时开启救援模式。</li>
<li>通过 Lish 进入Linode 系统后，首先修改 root 密码:<code>passwd</code>。</li>
<li>输入 root 密码。</li>
<li><p>输入以下命令启动 SSH 服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/ssh start</div></pre></td></tr></table></figure>
</li>
<li><p>在旧机器上输入命令开始传输硬盘。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/sda | ssh root@123.45.67.89 <span class="string">"dd of=/dev/sda"</span></div></pre></td></tr></table></figure>
</li>
<li><p>传输完毕，重启即可。</p>
</li>
</ol>
<h2 id="配置VPS和一些服务"><a href="#配置VPS和一些服务" class="headerlink" title="配置VPS和一些服务"></a>配置VPS和一些服务</h2><p>系统还是习惯了Centos7，也不用来做开发，不打算换成Ubuntu了,不用学太多东西，毕竟也不是从事相关方面工作，专注核心内容吧。所以，以下内容及命令均基于Centos7。</p>
<h3 id="切换内核并开启BBR"><a href="#切换内核并开启BBR" class="headerlink" title="切换内核并开启BBR"></a>切换内核并开启BBR</h3><p>阅读<a href="https://teddysun.com/489.html" target="_blank" rel="external">这篇博文</a>按照说明进行操作，以下是部分摘抄。</p>
<h4 id="内核升级方法"><a href="#内核升级方法" class="headerlink" title="内核升级方法"></a>内核升级方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml kernel-ml-devel</div><div class="line">grub2-set-default 0</div><div class="line">/usr/sbin/update-grub</div></pre></td></tr></table></figure>
<p>完成后，去<a href="https://www.linode.com/?r=2af2507483b1f6a2ac10fc9f757e43ac1d520477" target="_blank" rel="external">Linode</a>后台把内核切换成Grub2，重启即可。</p>
<h4 id="开启并验证BBR"><a href="#开启并验证BBR" class="headerlink" title="开启并验证BBR"></a>开启并验证BBR</h4><p>使用root用户登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</div><div class="line">chmod +x bbr.sh</div><div class="line">./bbr.sh</div></pre></td></tr></table></figure></p>
<p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。输入以下命令验证是否成功安装最新内核并开启 TCP BBR：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uname -r</div></pre></td></tr></table></figure></p>
<p>查看内核版本，含有 4.9 就表示 OK 了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure></p>
<p>返回值一般为：<code>net.ipv4.tcp_available_congestion_control = bbr cubic reno</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl net.ipv4.tcp_congestion_control</div></pre></td></tr></table></figure></p>
<p>返回值一般为：<code>net.ipv4.tcp_congestion_control = bbr</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl net.core.default_qdisc</div></pre></td></tr></table></figure></p>
<p>返回值一般为：<code>net.core.default_qdisc = fq</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsmod | grep bbr</div></pre></td></tr></table></figure></p>
<p>返回值有 <code>tcp_bbr</code> 模块即说明bbr已启动。</p>
<h3 id="安装SS"><a href="#安装SS" class="headerlink" title="安装SS"></a>安装SS</h3><p>阅读<a href="https://teddysun.com/342.html" target="_blank" rel="external">这篇博文</a>按照说明进行操作</p>
<h2 id="转移博客"><a href="#转移博客" class="headerlink" title="转移博客"></a>转移博客</h2><p>博客是基于静态网页的，整套系统依赖了nginx nodejs hexo git等，因此需要全部搭建好环境。</p>
<h3 id="安装OpenResty-nginx-lua"><a href="#安装OpenResty-nginx-lua" class="headerlink" title="安装OpenResty(nginx+lua)"></a>安装OpenResty(nginx+lua)</h3><h4 id="新建www用户"><a href="#新建www用户" class="headerlink" title="新建www用户"></a>新建www用户</h4><p>准备把博客网站之类的放在这个用户下管理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adduser www</div><div class="line">groupadd www</div><div class="line">usermod -G www www</div></pre></td></tr></table></figure></p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install wget readline-devel pcre-devel openssl-devel gcc curl</div></pre></td></tr></table></figure>
<h4 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h4><p>打开<a href="http://openresty.org/en/download.html" target="_blank" rel="external">OpenResty官方下载页面</a>获取最新版的地址，以下具体文件名或路径以本次操作为例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://openresty.org/download/openresty-1.11.2.2.tar.gz</div><div class="line">tar zxvf openresty-1.11.2.2.tar.gz</div><div class="line">cd openresty-1.11.2.2</div><div class="line">./configure --user=www --group=www --prefix=/usr/local --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module --with-pcre-jit --with-http_iconv_module -j4 &amp;&amp; make &amp;&amp; make install</div><div class="line">ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx</div></pre></td></tr></table></figure></p>
<h4 id="设置服务和开机启动"><a href="#设置服务和开机启动" class="headerlink" title="设置服务和开机启动"></a>设置服务和开机启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">cd /usr/lib/systemd/system</div><div class="line">vi nginx.service</div><div class="line">&lt;i&gt;&lt;Paste&gt;</div><div class="line">[Unit]</div><div class="line">Description=Nginx an HTTP and reverse proxy server.</div><div class="line">After=network.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">ExecStart=/usr/local/bin/nginx</div><div class="line">ExecStop=/usr/local/bin/nginx -s stop</div><div class="line">ExecReload=/usr/local/bin/nginx -s reload</div><div class="line">PrivateTmp=true</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div><div class="line">&lt;/Paste&gt;</div><div class="line">&lt;Esc&gt;&lt;:&gt;&lt;x&gt;&lt;Enter&gt;</div><div class="line">systemctl enable nginx</div><div class="line">systemctl start nginx</div></pre></td></tr></table></figure>
<h3 id="安装最新版本的git"><a href="#安装最新版本的git" class="headerlink" title="安装最新版本的git"></a>安装最新版本的git</h3><p>在<a href="https://github.com/git/git/releases" target="_blank" rel="external">这个页面</a>找到最新版地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/git/git/archive/v2.11.1.tar.gz</div><div class="line">mv v2.11.1.tar.gz git-v2.11.1.tar.gz</div><div class="line">yum remove git</div><div class="line">make prefix=/usr/<span class="built_in">local</span>/git all</div><div class="line">make prefix=/usr/<span class="built_in">local</span>/git install</div><div class="line">ln -s /usr/<span class="built_in">local</span>/git/bin/git /usr/<span class="built_in">local</span>/bin/git</div></pre></td></tr></table></figure></p>
<h4 id="新建git用户和组"><a href="#新建git用户和组" class="headerlink" title="新建git用户和组"></a>新建git用户和组</h4><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><h4 id="安装Node-Version-Manager"><a href="#安装Node-Version-Manager" class="headerlink" title="安装Node Version Manager"></a>安装Node Version Manager</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | NVM_DIR=/usr/<span class="built_in">local</span>/nvm bash</div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
<h4 id="安装Node-Lts-version"><a href="#安装Node-Lts-version" class="headerlink" title="安装Node Lts version"></a>安装Node Lts version</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nvm install --lts</div><div class="line">nvm use --lts</div></pre></td></tr></table></figure>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
<h3 id="转移HTTPS证书和DNS-ip"><a href="#转移HTTPS证书和DNS-ip" class="headerlink" title="转移HTTPS证书和DNS ip"></a>转移HTTPS证书和DNS ip</h3><p>先在DNS服务商那里转移ip。<br>按照<a href="https://blog.walkcd.com/lets-encrypt/" target="_blank" rel="external">这篇文章</a>重新安装lets-encrypt,并申请证书。<br>添加dhparam。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl dhparam -out /home/www/dhparam.pem 2048</div></pre></td></tr></table></figure></p>
<p>完毕后转移nginx配置文件按照原路径到新vps下</p>
<h3 id="安装Gogs-A-painless-self-hosted-Git-service"><a href="#安装Gogs-A-painless-self-hosted-Git-service" class="headerlink" title="安装Gogs(A painless self-hosted Git service)"></a>安装Gogs(A painless self-hosted Git service)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://dl.gogs.io/gogs_v0.9.141_linux_amd64.tar.gz</div><div class="line">tar zxvf gogs_v0.9.141_linux_amd64.tar.gz</div><div class="line">mv gogs /usr/<span class="built_in">local</span>/gogs</div><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/gogs</div><div class="line">./gogs web</div></pre></td></tr></table></figure>
<p>创建gogs服务并设置成开机启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">vi /usr/lib/systemd/system/gogs.service</div><div class="line">&lt;i&gt;&lt;Paste&gt;</div><div class="line">[Unit]</div><div class="line">Description=Gogs (Go Git Service)</div><div class="line">After=syslog.target</div><div class="line">After=network.target</div><div class="line">#After=mysqld.service</div><div class="line">#After=postgresql.service</div><div class="line">#After=memcached.service</div><div class="line">#After=redis.service</div><div class="line"></div><div class="line">[Service]</div><div class="line"># Modify these two values and uncomment them if you have</div><div class="line"># repos with lots of files and get an HTTP error 500 because</div><div class="line"># of that</div><div class="line">###</div><div class="line">#LimitMEMLOCK=infinity</div><div class="line">#LimitNOFILE=65535</div><div class="line">#Type=forking</div><div class="line">User=www</div><div class="line">Group=www</div><div class="line">WorkingDirectory=/usr/local/gogs</div><div class="line">ExecStart=/usr/local/gogs/gogs web</div><div class="line">Restart=always</div><div class="line">Environment=USER=www HOME=/home/www</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div><div class="line">&lt;/Paste&gt;</div><div class="line">&lt;Esc&gt;&lt;:&gt;&lt;x&gt;&lt;Enter&gt;</div><div class="line">systemctl enable gogs</div><div class="line">systemctl start gogs</div></pre></td></tr></table></figure></p>
<h3 id="配置自动部署博客"><a href="#配置自动部署博客" class="headerlink" title="配置自动部署博客"></a>配置自动部署博客</h3><h4 id="新建项目并提交"><a href="#新建项目并提交" class="headerlink" title="新建项目并提交"></a>新建项目并提交</h4><p>把本地的博客git更换新地址并提交到gogs。</p>
<h4 id="测试并添加githook"><a href="#测试并添加githook" class="headerlink" title="测试并添加githook"></a>测试并添加githook</h4><p>先克隆一个用于生成网站的本地仓库。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> <span class="variable">$&#123;REMOTE_REP&#125;</span> <span class="variable">$&#123;BLOG_GENERATE_REP&#125;</span></div><div class="line"><span class="built_in">cd</span> <span class="variable">$&#123;BLOG_GENERATE_REP&#125;</span></div><div class="line">npm install hexo --save</div><div class="line">npm install hexo-generator-archive --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div><div class="line">npm install hexo-generator-category --save</div><div class="line">npm install hexo-generator-index --save</div><div class="line">npm install hexo-generator-search --save</div><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-tag --save</div><div class="line">npm install hexo-pagination --save</div><div class="line">npm install hexo-renderer-ejs --save</div><div class="line">npm install hexo-renderer-marked --save</div><div class="line">npm install hexo-renderer-stylus --save</div><div class="line">npm install hexo-server --save</div></pre></td></tr></table></figure></p>
<p>在仓库设置里添加post-receive的钩子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/bin/bash -l</span></div><div class="line"><span class="built_in">unset</span> $(git rev-parse --<span class="built_in">local</span>-env-vars)</div><div class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"/usr/local/nvm"</span></div><div class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></div><div class="line">nvm use --lts</div><div class="line"><span class="built_in">cd</span> <span class="variable">$&#123;BLOG_GENERATE_REP&#125;</span></div><div class="line">git pull</div><div class="line">hexo clean</div><div class="line">hexo g</div><div class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class="line">cp -rf <span class="variable">$&#123;GENERATED_PUBLIC&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></div></pre></td></tr></table></figure></p>
<p>提交新文件就会更新博客网站了。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>完毕撒花~睡觉~</p>
]]></content>
      
        <categories>
            
            <category> vps </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vps </tag>
            
            <tag> centos </tag>
            
            <tag> blogs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为Windows10 Bash添加右键菜单“Bash Here”]]></title>
      <url>/windows10-bash-here/</url>
      <content type="html"><![CDATA[<p>最近更新了Windows10一周年版，那么Bash肯定要拿来试试了。经过体验后，可以明确这个东东就是一个Ubuntu，自带的默认sh是dash。那么如果我们想随时随地使用他，就像git-bash右键菜单那样简单，应该怎么做呢？<br>新建一个文本文件，文件名改成*.reg，用文本编辑器编辑它，添加如下内容：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Windows Registry Editor Version 5.00</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\Directory\shell\Bash]</div><div class="line">@=&quot;Bash Here&quot;</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\Directory\shell\Bash\command]</div><div class="line">@=&quot;cmd /s /k \&quot;pushd %v &amp;&amp; bash\&quot;&quot;</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Bash]</div><div class="line">@=&quot;Bash Here&quot;</div><div class="line"></div><div class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\Bash\command]</div><div class="line">@=&quot;cmd /s /k \&quot;pushd %v &amp;&amp; bash\&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>保存后双击导入即可，现在我们可以在任意文件夹空白地区和文件夹右键看到我们的右键菜单“Bash Here”了。</p>
]]></content>
      
        <categories>
            
            <category> windows10 </category>
            
            <category> regedit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows10 </tag>
            
            <tag> bash </tag>
            
            <tag> regedit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【UE4】根据路径动态加载蓝图类的正确方式]]></title>
      <url>/ue4-dynamic-load-blueprint-class-from-path/</url>
      <content type="html"><![CDATA[<p>由于要在脚本里实现根据路径动态加载蓝图类，我添加了一个胶水方法。思路是加载一个蓝图文件，然后获取到其GeneratedClass。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> BP = Cast&lt;UBlueprint&gt;(StaticLoadObject(UBlueprint::StaticClass(), <span class="literal">nullptr</span>, *Path));</div><div class="line">UClass* Class =  BP ? BP-&gt;GeneratedClass : <span class="literal">nullptr</span></div></pre></td></tr></table></figure></p>
<p>这个方法在桌面平台PIE的情况下没有什么问题，直到我们cook资源后，在移动平台上测试才出现了错误。因为，cook过的资源是没有蓝图对象的。</p>
<a id="more"></a>
<p>那么我们需要换一种写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UClass* Class = Cast&lt;UClass&gt;(StaticLoadObject(UClass::StaticClass(), <span class="literal">nullptr</span>, *Path));</div></pre></td></tr></table></figure></p>
<p>这样一来，配置的路径也要相应的从<br><code>/Game/YOURDIR/BP_SomeBlueprint.BP_SomeBlueprint</code><br>改成<br><code>/Game/YOURDIR/BP_SomeBlueprint.BP_SomeBlueprint_C</code>。</p>
<p>当然还有一种糟糕的方式：修改<code>DefaultEditor.ini</code><br>将<code>bDontLoadBlueprintOutsideEditor=true</code>改成<code>false</code><br>这种方式的本质是使cook过的资源也保留蓝图部分，会影响包大小，因此极其不推荐。</p>
]]></content>
      
        <categories>
            
            <category> ue4 </category>
            
            <category> asset </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ue4 </tag>
            
            <tag> blueprint </tag>
            
            <tag> load </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Let’s Encrypt! 为博客开启https]]></title>
      <url>/lets-encrypt/</url>
      <content type="html"><![CDATA[<p>看过<a href="http://zhiguang.me/2016/03/21/lets-encrypt/" target="_blank" rel="external">之光的文章</a>后，跃跃欲试，实践后整理了nginx的部分。<br>运行环境如下：</p>
<ul>
<li>cat /etc/redhat-release &gt; CentOS Linux release 7.2.1511 (Core)</li>
<li>nginx -v &gt; nginx version: openresty/1.9.15.1</li>
<li>blog &gt; hexo</li>
</ul>
<a id="more"></a>
<h2 id="用git下载客户端并安装依赖："><a href="#用git下载客户端并安装依赖：" class="headerlink" title="用git下载客户端并安装依赖："></a>用git下载客户端并安装依赖：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt</div><div class="line"><span class="built_in">cd</span> letsencrypt</div><div class="line">./letsencrypt-auto --<span class="built_in">help</span></div></pre></td></tr></table></figure>
<h2 id="开始申请"><a href="#开始申请" class="headerlink" title="开始申请"></a>开始申请</h2><p>申请证书时客户端需要使用80和443端口，因此先停掉nginx：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop nginx</div></pre></td></tr></table></figure></p>
<p>申请证书：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./letsencrypt-auto certonly --standalone</div></pre></td></tr></table></figure></p>
<p>按照屏幕提示依次输入联系email、同意Terms of Service、输入域名。</p>
<h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑nginx.conf <code>/usr/local/nginx/conf/vhost/blog.walkcd.com.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">    &#123;</div><div class="line">        listen 80;</div><div class="line">        listen 443 ssl;</div><div class="line"></div><div class="line">        server_name blog.walkcd.com; #替换成自己的域名</div><div class="line">        index index.html;</div><div class="line">        root  /home/www/blog.walkcd.com;</div><div class="line">    	ssl_certificate /etc/letsencrypt/live/blog.walkcd.com/fullchain.pem; # 替换成自己的证书和密钥</div><div class="line">    	ssl_certificate_key /etc/letsencrypt/live/blog.walkcd.com/privkey.pem;</div><div class="line">    	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    	ssl_dhparam /home/www/dhparam.pem;</div><div class="line">    	ssl_session_cache shared:SSL:10m;</div><div class="line">	    ssl_session_timeout 10m;</div><div class="line"></div><div class="line">        # 重定向到https</div><div class="line">        if ($server_port = 80)&#123;</div><div class="line">    	    return 301 https://$server_name$request_uri;</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">        if ($scheme = http)&#123;</div><div class="line">            return 301 https://$server_name$request_uri;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    	error_page 497 https://$server_name$request_uri;</div><div class="line"></div><div class="line">    	error_page   404   /404.html;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>重新启动nginx<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start nginx</div></pre></td></tr></table></figure></p>
<h2 id="自动续期证书"><a href="#自动续期证书" class="headerlink" title="自动续期证书"></a>自动续期证书</h2><p>由于Let’s Encrypt的证书有效期只有90天，因此编写一个脚本自动地renew证书：<code>letsencrypt_renew.sh</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">sudo systemctl stop nginx</div><div class="line">/home/www/letsencrypt/letsencrypt-auto renew --force-renew</div><div class="line">sudo systemctl start nginx</div></pre></td></tr></table></figure></p>
<p>编辑crontab，每月1日自动调用脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 0 1 * * /home/www/letsencrypt/renew.sh &gt;&gt; /home/www/logs/letsencrypt_renew.log 2&gt;&amp;1</div></pre></td></tr></table></figure></p>
<p>这样就大功告成了。</p>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> letsencrypt </tag>
            
            <tag> ssl </tag>
            
            <tag> https </tag>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[将VPS系统切换到CentOS7]]></title>
      <url>/change-vps-os-to-centos-7/</url>
      <content type="html"><![CDATA[<p>纠结了很久，终于决定和CentOS6说拜拜，主要还是对新的systemd比较感兴趣，确实使用起来很方便。同时也是彻底抛弃WordPress的时候了，这个庞然大物用起来越发的觉得不痛快了。主要原因还是并不能原生支持纯粹的Markdown写作，而团队已经开始大量使用Markdown来撰写文档了。<br><a id="more"></a></p>
<h2 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h2><p>切换之前当然要对之前博客里的数据做个备份了，直接设置里导出XML完事，图片都不要了（主要还是因为懒得搞）。</p>
<h3 id="VPS-ChangeOS"><a href="#VPS-ChangeOS" class="headerlink" title="VPS ChangeOS"></a>VPS ChangeOS</h3><p>直接在VPS后台ChangeOS即可，数据会被清空，一般5分钟内搞定，就可以登录开始配置了。</p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul>
<li><a href="https://www.baidu.com/s?wd=自己动手丰衣足食" target="_blank" rel="external">shadowsocks</a></li>
<li><a href="http://openresty.org/en/" target="_blank" rel="external">openresty</a></li>
<li><a href="https://github.com/git/git" target="_blank" rel="external">git</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="external">hexo</a></li>
</ul>
<h3 id="额外优化和安全配置"><a href="#额外优化和安全配置" class="headerlink" title="额外优化和安全配置"></a>额外优化和安全配置</h3><ul>
<li>添加用户</li>
<li>修改ssh端口，禁止root用密码登录</li>
<li>添加swap空间大小</li>
</ul>
<h2 id="初探systemd"><a href="#初探systemd" class="headerlink" title="初探systemd"></a>初探systemd</h2><p>CentOS 7 使用systemd替换了SysV。Systemd目的是要取代Unix时代以来一直在使用的init系统。systemd的特性有：</p>
<ul>
<li>支持并行化任务</li>
<li>同时采用socket式与D-Bus总线式激活服务</li>
<li>按需启动守护进程（daemon）</li>
<li>利用 Linux 的 cgroups 监视进程</li>
<li>支持快照和系统恢复</li>
<li>维护挂载点和自动挂载点</li>
<li>各服务间基于依赖关系进行精密控制</li>
</ul>
<p>检视和控制systemd的主要命令是systemctl。该命令可用于查看系统状态和管理系统及服务。详见man systemctl。</p>
<h3 id="systemctl常见用法"><a href="#systemctl常见用法" class="headerlink" title="systemctl常见用法"></a>systemctl常见用法</h3><p>复杂的用法我们一般也用不着，就列几个常用的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 立即激活service：</span></div><div class="line">  systemctl start <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 立即停止service：</span></div><div class="line">  systemctl stop <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 重启service：</span></div><div class="line">  systemctl restart <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 命令service重新读取配置：</span></div><div class="line">  systemctl reload <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 输出service运行状态：</span></div><div class="line">  systemctl status <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 检查service是否配置为自动启动：</span></div><div class="line">  systemctl is-enabled <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 开机自动激活service：</span></div><div class="line">  systemctl <span class="built_in">enable</span> <span class="variable">$service_name</span></div><div class="line"><span class="comment"># 取消开机自动激活service：</span></div><div class="line">  systemctl <span class="built_in">disable</span> <span class="variable">$service_name</span></div></pre></td></tr></table></figure>
<h3 id="添加自己的service"><a href="#添加自己的service" class="headerlink" title="添加自己的service"></a>添加自己的service</h3><p>CentOS 7的服务systemctl脚本存放在：<code>/usr/lib/systemd/</code>，有系统（system）和用户（user）之分，像需要开机不登陆就能运行的程序，还是存在系统服务里吧。即：<code>/usr/lib/systemd/system</code>目录下<br>每一个服务以.service结尾，一般会分为3部分：[Unit]、[Service]和[Install]。</p>
<p>以nginx为例，我的nginx版本是openresty源码编译的，因此没有自带service配置，我们可以自己写一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Nginx an HTTP and reverse proxy server.</div><div class="line">After=network.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=forking</div><div class="line">ExecStart=/usr/local/bin/nginx</div><div class="line">ExecStop=/usr/local/bin/nginx -s stop</div><div class="line">ExecReload=/usr/local/bin/nginx -s reload</div><div class="line">PrivateTmp=true</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>具体解释请看<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/chap-Managing_Services_with_systemd.html" target="_blank" rel="external">文档</a>。从以上示例可以发现，我们无需再自己重复编写繁琐的init.d脚本，还是很方便的。</p>
<h2 id="FireWall的常见用法"><a href="#FireWall的常见用法" class="headerlink" title="FireWall的常见用法"></a>FireWall的常见用法</h2><p>之前的防火墙用的是iptables，每次设置还得找教程，CentOS7默认使用firewalld作防火墙。<br>添加ssh端口，https端口都要用到，正好简单学习下。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 开放端口</span></div><div class="line">  firewall-cmd --add-port=1234/tcp</div><div class="line"><span class="comment"># 关闭端口</span></div><div class="line">  firewall-cmd --remove-port=1234/tcp</div><div class="line"><span class="comment"># 永久开放端口</span></div><div class="line">  firewall-cmd --add-port=443/tcp --permanent</div><div class="line"><span class="comment"># 重新加载配置使其立即生效</span></div><div class="line">  firewall-cmd --reload</div><div class="line"><span class="comment"># 查看当前配置</span></div><div class="line">  firewall-cmd --list-all</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
            <category> centos7 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> centos7 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为Lua添加std::function交互支持]]></title>
      <url>/add-stdfunction-interactive-support-for-lua/</url>
      <content type="html"><![CDATA[<p>我们常用的事件等机制需要设置回调函数，在C++中比较方便的是std::function配合lambda使用。当我们使用lua进行脚本化的时候，lua和C++交互便会遇到这样的问题，那么如何在lua脚本中设置和获取std::function作为变量呢？要解决这个问题，我们需要搞定两个方向——Lua-&gt;C++和 C++-&gt;Lua。</p>
<a id="more"></a>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="Lua-gt-C"><a href="#Lua-gt-C" class="headerlink" title="Lua-&gt;C++"></a>Lua-&gt;C++</h3><p>假如我们有一个回调函数需要设置<code>std::function&lt;void(int)&gt;</code> 该函数在Lua中可能是这样的：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span><span class="params">(tag)</span></span></div><div class="line"><span class="built_in">print</span>(<span class="string">"tag is :"</span> .. tag)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>它是一个Lua函数，我们可以在Lua栈中获取到它，那么如果我需要在以后调用它，我可以使用<span class="s1">luaL_ref将其注册，在需要调用的时候获取到它的引用，并使用</span><span class="s1">lua_pcall调用它。这样一来思路就清晰了，我们只需要使用lambda表达式构造出一个std::function，内容就是获取到这个Lua function并调用，在这个过程中使用lambda捕获Lua function的引用id，并在function销毁时进行解引用。</span></p>
<h3 id="C-gt-Lua"><a href="#C-gt-Lua" class="headerlink" title="C++-&gt;Lua"></a>C++-&gt;Lua</h3><p>如果是一个std::function压入Lua栈呢，我们可以简单的使用userdata进行储存，使用<span class="s1">lua_newuserdata开一块内存，将std::function拷贝进去，设置好元表，这样就完成了压入栈的操作。</span></p>
<h3 id="C-gt-Lua-gt-C"><a href="#C-gt-Lua-gt-C" class="headerlink" title="C++-&gt;Lua-&gt;C++"></a>C++-&gt;Lua-&gt;C++</h3><p>通过2存入std::function这样问题又来了，传进来的参数有可能是一个function也有可能是一个userdata，我们需要对其分别处理，如果是function，使用lambda进行转换，如果是userdata，直接还原内存。</p>
<p>经过上面的分析，我们可以实现其以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionTransfer</span> &#123;</span></div><div class="line">    lua_State *state;</div><div class="line">    <span class="keyword">int</span> ref;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FunctionTransfer(lua_State *L, <span class="keyword">int</span> index)</div><div class="line">    &#123;</div><div class="line">        state = L;</div><div class="line">        ref = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (state) &#123;</div><div class="line">            lua_pushvalue(state, index);</div><div class="line">            ref = luaL_ref(state, LUA_REGISTRYINDEX);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R , <span class="keyword">typename</span>... P&gt;</div><div class="line">    static void create(lua_State *L, int index, std::function&lt;R(P...)&gt; &amp;func)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> auf = <span class="built_in">std</span>::make_shared&lt;FunctionTransfer&gt;(L, index);</div><div class="line">        func = [auf](P... p)-&gt;R&#123;</div><div class="line">            lua_State *L = auf-&gt;getState();</div><div class="line">            lua_rawgeti(L, LUA_REGISTRYINDEX, auf-&gt;getRef());</div><div class="line">            <span class="keyword">int</span> nargs = pushArgs(L, p...);</div><div class="line">            lua_pcall(L, nargs, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> Stack&lt;R&gt;::get(L, <span class="number">-1</span>);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R = <span class="keyword">void</span>, <span class="keyword">typename</span>... P&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> create(lua_State *L, <span class="keyword">int</span> index, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(P...)&gt; &amp;func)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> auf = <span class="built_in">std</span>::make_shared&lt;FunctionTransfer&gt;(L, index);</div><div class="line">        func = [auf](P... p)-&gt;<span class="keyword">void</span>&#123;</div><div class="line">            lua_State *L = auf-&gt;getState();</div><div class="line">            lua_rawgeti(L, LUA_REGISTRYINDEX, auf-&gt;getRef());</div><div class="line">            <span class="keyword">int</span> nargs = pushArgs(L, p...);</div><div class="line">            lua_pcall(L, nargs, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... P&gt;</div><div class="line">    static void create(lua_State *L, int index, std::function&lt;void(void)&gt; &amp;func)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> auf = <span class="built_in">std</span>::make_shared&lt;FunctionTransfer&gt;(L, index);</div><div class="line">        func = [auf]()-&gt;<span class="keyword">void</span>&#123;</div><div class="line">            lua_State *L = auf-&gt;getState();</div><div class="line">            lua_rawgeti(L, LUA_REGISTRYINDEX, auf-&gt;getRef());</div><div class="line">            lua_pcall(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FT&gt;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(lua_State *L, <span class="keyword">int</span> index, <span class="built_in">std</span>::function&lt;FT&gt; &amp;func)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(lua_isfunction(L, index))</div><div class="line">        &#123;</div><div class="line">            create(L, index, func);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lua_isuserdata(L, index))</div><div class="line">        &#123;</div><div class="line">            func = (<span class="keyword">decltype</span>(func)(*luaL_checkudata(L, index, <span class="keyword">typeid</span>(func).name())));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            luaL_checktype(L, index, LUA_TFUNCTION);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRef</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ref;&#125;</div><div class="line">    <span class="function">lua_State* <span class="title">getState</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> state;&#125;</div><div class="line"></div><div class="line">    ~FunctionTransfer()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (state) &#123;</div><div class="line">            luaL_unref(state, LUA_REGISTRYINDEX, ref);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FT&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &lt;std::function&lt;FT&gt; &gt;</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span> <span class="params">(lua_State* L, <span class="built_in">std</span>::function&lt;FT&gt; func)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">new</span> (lua_newuserdata(L, <span class="keyword">sizeof</span>(func))) <span class="built_in">std</span>::function&lt;FT&gt;(func);</div><div class="line">        luaL_newmetatable(L, <span class="keyword">typeid</span>(func).name());</div><div class="line">        lua_setmetatable(L, <span class="number">-2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">std</span>::function&lt;FT&gt; get (lua_State* L, <span class="keyword">int</span> index)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::function&lt;FT&gt; func;</div><div class="line">        FunctionTransfer::get(L, index, func);</div><div class="line">        <span class="keyword">return</span> func;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>这里的std::function的userdata的metatable是没有实现__call方法的，因此实际上在lua层并不能调用这个方法。有需要的话可以自行实现。</p>
]]></content>
      
        <categories>
            
            <category> programming language </category>
            
            <category> c/c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> lua </tag>
            
            <tag> luabridge </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
